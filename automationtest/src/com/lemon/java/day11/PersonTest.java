package com.lemon.java.day11;

/*
 * 方法的重写(override / overwrite)
 * 1.重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作.
 * 2.应用：重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法
 * 3.重写的规定：
 *      方法的声明：权限修饰符 返回值类型 方法名（形参列表）throws 异常的类型 {
 *                      //方法体
 *                  }
 *      约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法
 *     ①，子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同
 *     ②，子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符(重写的子类必须比父类的权限大)
 *     ③，子类不能重写父类中private的权限(private权限太小了，子类中看不到，如果写了不是重写，是直接自己定义了一个)
 *     ④，返回值类型：
 *              >如果父类被重写的方法返回值类型是void，子类重写的方法的返回值类型只能是void
 *              >父类被重写的方法的返回值类型是A类型，则子类重写的方法是返回值类型是A类或A的子类.
 *              >父类被重写的方法的返回值类型是基本数据类型(比如:double)，则子类重写的方法的返回值类型必须是相同的基本数据类型
 *
 *     ⑤，子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型(具体放到异常处理)
 *
 *      子类和父类中的同名通参数的方法要么都声明为非static的(考虑重写)，要么都声明为static的(不是重写)[static不能被重写，如果父类加static子类也必须加，如果加了static就不是重写了]
 * 题目：区分方法的重载与重写
 * 重载：一个类中定义得多个构造器，彼此够成重载
 * 重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作.
 */
public class PersonTest {
    public static void main(String[] args) {
        Student s= new Student("软件工程");
        s.eat();
        s.walk(2);
        s.study();
        Person d = new Person("ss",11);
        d.eat();
        System.out.println(8/1);
    }
}
